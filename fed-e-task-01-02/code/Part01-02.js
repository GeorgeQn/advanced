/*
 * @Descripttion: 
 * @version: 
 * @Author: QinJiaJun
 * @Date: 2020-10-14 13:03:21
 * @LastEditors: sueRimn
 * @LastEditTime: 2020-10-14 16:52:59
 */

//模块二 ES 新特性与 TypeScript、JS 性能优化

// 一，请说出下列最终的执行结果，并解释为什么。
    // var a = [];
    // for ( var i = 0;i < 10; i ++){
    //     a[i] = function(){
    //         console.log(i)
    //     }
    // }
    // a[6]()
// a[6]() 结果为 10 ,因为for循环走完了，才分别调用a数组里面下表为6的方法

//二，请说出下列最终的执行结果，并解释为什么。
    // var tmp = 123;
    // if(true){
    //     console.log(tmp);
    //     let tmp;
    // }
//会报错。因为let没有变量提升，但是在这之前就实用tmp，所以会报错

//三，结合ES6新语法，用最简单的方式找出数组中的最小值；
    // var arr = [12,34,32,89,4]
    // let arrMin = Math.min.apply(null,arr);
    // console.log(arrMin,'arrMin')

//四，请详细说明var let const 三种声明变量方式之间的具体差别。
// var会变量提升，是es5的语法，只有全局作用域和函数作用域。let不会变量提升，是es6新语法，有块级作用域，省去了es5用闭包来做作用域保护的场景，const作用域和let一样都是块级租用与声明的为常量，区别是一旦被赋值就不能改变

//五 请说出下列代码最终输出结果，并解释为什么。
    // var a = 10;
    // var obj = {
    //     a:20,
    //     fn(){
    //         setTimeout(()=>{
    //             console.log(this.a)
    //         })
    //     }
    // }
    // obj.fn();

//结果为20，不知道怎么解释，因为不知道想考什么，闭包？异步？堆栈？，堆栈的话先执行a = 10，obj = {}；然后再执行引入的fn（）

//六，简述Symbol 类型的用途。
//在ES5中，对象属性名都是字符串容易造成属性名冲突。为了避免这种七年概况的发生，ES6引入了新的原始数据类型Symbol，表示独一无二的值。

//七，说说什么是浅拷贝，什么是深拷贝？
//堆栈里面，浅拷贝就是拷贝第一层，拷贝的是指向的地址，如果是几层的深拷贝，可以运用concat的。

//八，请简述TypeScript与JavaScript之间的关系。
//typescript是javascript的一种超集。新增了静态类型，模块，类，接口和类型注解。

//九，请谈谈你所认为的typeScript的优缺点
//（1）增强代码的可读性和可维护性，强类型的系统相当于最好的文档，在编译时即可发现大部分的错误，增强编辑器的功能。
// （2）包容性，js文件可以直接改成 ts 文件，不定义类型可自动推论类型，可以定义几乎一切类型，ts 编译报错时也可以生成 js 文件，兼容第三方库，即使不是用ts编写的
// （3）有活跃的社区，大多数的第三方库都可提供给 ts 的类型定义文件，完全支持 es6 规范
// 使用 TS 的缺点：
// （1）增加学习成本，需要理解接口（Interfaces）和泛型（Generics），类（class），枚举类型（Enums）
// （2）短期增加开发成本，增加类型定义，但减少维护成本
// （3）ts 集成到构建流程需要一定的工作量
// （4）和有些库结合时不是很完美

//十，描述引用技术的工作原理和优缺点。
//引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程

//十一，描述标记整理算法的工作流程。
//让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

//十二，描述V8中新生代存储区垃圾回收的流程。
//将内存分威新生代和老生代，以存活市场为判断。新生代分威From和To空建，一个闲置一个存活，在两个空间中作复制和对换。检测新生代是否经历过一次清理海存在，如果是就复制到老生代，不是的话就复制到To空间。或者To空间在从From到To的过程中，已经用了超过25%，那么直接将对象复制到老生代。

//十三，描述增量标记算法在何时实用及工作原理。
// 标记增量，就是把一整段的垃圾回收操作，拆分成多个小步，整合着完成垃圾回收，从而去替代一口气做完的垃圾回收操作。这样的好处主要就是垃圾回收和程序执行是交替着进行工作，这样时间消耗更合理一些。
// 可参照图例
// 在这里插入图片描述

// 当程序执行到一个阶段，由于是在老生代区域操作会由循环遍历对象进行标记，然后程序会继续执行，接着再进行标记，直到程序把垃圾对象都标记完，然后进行清除，当然这不是一次标记完成的。
// 当老生代区域内存达到1.5G 时V8就会触发最大的垃圾回收即非增量垃圾回收，时间也不会超过1s 钟，所以看似程序停顿很多次，其实不影响用户使用感官的。
